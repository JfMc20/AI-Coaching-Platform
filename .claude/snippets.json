{
  "fastapi_endpoint": {
    "prefix": "fastapi-endpoint",
    "description": "Create a new FastAPI endpoint with multi-tenant authentication",
    "body": [
      "@app.${1:post}(",
      "    \"/api/v1/${2:endpoint}\",",
      "    response_model=${3:ResponseModel},",
      "    tags=[\"${4:tag}\"],",
      "    summary=\"${5:Summary}\",",
      "    description=\"${6:Description}\"",
      ")",
      "async def ${7:function_name}(",
      "    request: ${8:RequestModel},",
      "    current_user: UserContext = Depends(get_current_user),",
      "    session: AsyncSession = Depends(get_tenant_session),",
      "):",
      "    \"\"\"${9:Function description}\"\"\"",
      "    try:",
      "        # Validate creator access",
      "        if current_user.creator_id != request.creator_id:",
      "            raise HTTPException(",
      "                status_code=status.HTTP_403_FORBIDDEN,",
      "                detail=\"Access denied: Cannot access other creator's data\"",
      "            )",
      "        ",
      "        # Your implementation here",
      "        ${10:implementation}",
      "        ",
      "    except HTTPException:",
      "        raise",
      "    except Exception as e:",
      "        logger.error(f\"${11:operation} error: {str(e)}\")",
      "        raise HTTPException(",
      "            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,",
      "            detail=f\"${12:operation} failed: {str(e)}\"",
      "        )"
    ]
  },
  "pydantic_model": {
    "prefix": "pydantic-model",
    "description": "Create a Pydantic model for request/response",
    "body": [
      "class ${1:ModelName}(BaseModel):",
      "    \"\"\"${2:Model description}\"\"\"",
      "    ",
      "    ${3:field_name}: ${4:str} = Field(",
      "        ..., ",
      "        description=\"${5:Field description}\",",
      "        ${6:min_length=1, max_length=255}",
      "    )",
      "    creator_id: str = Field(..., description=\"Creator identifier for tenant isolation\")",
      "    ${0}"
    ]
  },
  "database_model": {
    "prefix": "db-model",
    "description": "Create a database model with multi-tenant support",
    "body": [
      "class ${1:ModelName}(BaseTenantModel):",
      "    \"\"\"${2:Model description} - MUST inherit from BaseTenantModel\"\"\"",
      "    __tablename__ = \"${3:table_name}\"",
      "    ",
      "    ${4:field_name}: str = Field(..., description=\"${5:Field description}\")",
      "    # creator_id is inherited from BaseTenantModel",
      "    # RLS policies automatically filter by creator_id",
      "    ${0}"
    ]
  },
  "test_class": {
    "prefix": "test-class",
    "description": "Create a test class with multi-tenant testing",
    "body": [
      "class Test${1:FeatureName}:",
      "    \"\"\"Test suite for ${2:feature name} with multi-tenant isolation\"\"\"",
      "    ",
      "    @pytest.mark.asyncio",
      "    async def test_${3:test_name}_success(",
      "        self,",
      "        async_client: AsyncClient,",
      "        auth_fixtures: dict,",
      "        db_session: AsyncSession",
      "    ):",
      "        \"\"\"Test successful ${4:operation}\"\"\"",
      "        # Arrange",
      "        creator_id = \"test-creator-1\"",
      "        token = auth_fixtures[\"valid_token\"]",
      "        ",
      "        ${5:test_data} = {",
      "            \"${6:field}\": \"${7:value}\",",
      "            \"creator_id\": creator_id",
      "        }",
      "        ",
      "        # Act",
      "        response = await async_client.${8:post}(",
      "            \"/api/v1/${9:endpoint}\",",
      "            json=${10:test_data},",
      "            headers={\"Authorization\": f\"Bearer {token}\"}",
      "        )",
      "        ",
      "        # Assert",
      "        assert response.status_code == ${11:200}",
      "        data = response.json()",
      "        assert data[\"${12:field}\"] == \"${13:expected_value}\"",
      "        assert data[\"creator_id\"] == creator_id",
      "        ${0}"
    ]
  },
  "multi_tenant_test": {
    "prefix": "test-isolation",
    "description": "Create a multi-tenant isolation test",
    "body": [
      "@pytest.mark.asyncio",
      "async def test_${1:feature}_multi_tenant_isolation(",
      "    self,",
      "    async_client: AsyncClient,", 
      "    auth_fixtures: dict,",
      "    db_session: AsyncSession",
      "):",
      "    \"\"\"Test that creators can only see their own ${2:resources}\"\"\"",
      "    # Arrange - Create ${3:resources} for different creators",
      "    creator1_id = \"creator-1\"",
      "    creator2_id = \"creator-2\"",
      "    ",
      "    ${4:resource1} = ${5:Model}(${6:field}=\"Creator 1 ${7:Resource}\", creator_id=creator1_id)",
      "    ${8:resource2} = ${9:Model}(${10:field}=\"Creator 2 ${11:Resource}\", creator_id=creator2_id)",
      "    ",
      "    db_session.add_all([${12:resource1}, ${13:resource2}])",
      "    await db_session.commit()",
      "    await db_session.refresh(${14:resource1})",
      "    await db_session.refresh(${15:resource2})",
      "    ",
      "    # Act - Creator 1 tries to access Creator 2's ${16:resource}",
      "    token1 = auth_fixtures[\"creator1_token\"]",
      "    response = await async_client.get(",
      "        f\"/api/v1/${17:endpoint}/{${18:resource2}.id}\",",
      "        headers={\"Authorization\": f\"Bearer {token1}\"}",
      "    )",
      "    ",
      "    # Assert - Should not find the ${19:resource} (due to RLS)",
      "    assert response.status_code == 404",
      "    ${0}"
    ]
  },
  "ai_integration": {
    "prefix": "ai-integration",
    "description": "Create AI integration with Ollama and ChromaDB",
    "body": [
      "# AI Integration with creator isolation",
      "from shared.ai.ollama_manager import get_ollama_manager",
      "from shared.ai.chromadb_manager import get_chromadb_manager",
      "",
      "async def ${1:process_ai_request}(creator_id: str, ${2:query}: str):",
      "    \"\"\"${3:Process AI request with creator-specific context}\"\"\"",
      "    try:",
      "        # Get AI managers",
      "        ollama = get_ollama_manager()",
      "        chromadb = get_chromadb_manager()",
      "        ",
      "        # Generate embeddings",
      "        embeddings = await ollama.generate_embeddings([${4:query}])",
      "        ",
      "        # Search creator-specific collection",
      "        collection_name = f\"creator_{creator_id}_knowledge\"",
      "        results = await chromadb.query_collection(",
      "            collection_name=collection_name,",
      "            query_embeddings=embeddings.embeddings[0],",
      "            n_results=${5:5}",
      "        )",
      "        ",
      "        # Generate response using retrieved context",
      "        context = \"\\n\".join([doc[\"content\"] for doc in results[\"documents\"][0]])",
      "        prompt = f\"Context: {context}\\n\\nQuery: ${6:query}\\n\\nResponse:\"",
      "        ",
      "        response = await ollama.generate_chat_response(",
      "            prompt=prompt,",
      "            temperature=${7:0.7}",
      "        )",
      "        ",
      "        return {",
      "            \"response\": response.response,",
      "            \"sources\": results[\"documents\"][0],",
      "            \"processing_time_ms\": response.processing_time_ms",
      "        }",
      "        ",
      "    except Exception as e:",
      "        logger.error(f\"AI processing error: {str(e)}\")",
      "        raise",
      "        ${0}"
    ]
  },
  "env_value": {
    "prefix": "env-value",
    "description": "Get environment variable with fallback",
    "body": [
      "from shared.config.env_constants import get_env_value, ${1:VARIABLE_NAME}",
      "",
      "${2:value} = get_env_value(${3:VARIABLE_NAME}, default=\"${4:default_value}\")",
      "${0}"
    ]
  }
}